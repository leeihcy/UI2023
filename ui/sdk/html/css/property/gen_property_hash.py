import os
import sys
import shutil
import subprocess

"""
生成property完美hash, 用于实现O(1)将name转成id 
调用示例：
python gen_property_hash.py output_dir

输出：
property_id.template
property_id_hash.cpp
"""


SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))


def read_property_id_name_list():
  """
  从property_id.h中读取所有的属性列表
  """
  property_id_h_path = os.path.join(SCRIPT_DIR, "property_id.h")

  class StateContext:
    def __init__(self):
      self.state = 0
      self.result = []

  def state_find_enum(line, c):
    if line.startswith("enum class CSSPropertyId"): 
      c.state+=1
  def state_get_id_name(line, c):
    line = line.strip(" \t\n\r")
    if line.startswith("}"):
      c.state+=1
      return

    if line[:2] == "//":
      return
    
    # 格式：
    # PropertyId = 99, // "PropertyName"

    id = line.split(",")[0].split("=")[0].strip()
    if "//" not in line:
      return
    value = line.split("//")[-1].strip()

    if id and value:
      c.result.append((id, value))

  def state_pass(line, c):
    pass
  
  # 状态机
  state_function = [
    state_find_enum,
    state_get_id_name,
    state_pass
  ]

  c = StateContext()
  with open(property_id_h_path, "r", encoding="utf-8") as f:
    for line in f:
      state_function[c.state](line, c)

  return c.result


def gen_gperf_template(output_dir, properties):
  """
  生成gperf输入模板
  """
  # output_dir = os.path.join(SCRIPT_DIR, "gen")
  if not os.path.exists(output_dir):
    os.mkdir(output_dir)

  template_path = os.path.join(output_dir, "property_id.template")
  with open(template_path, "w", encoding="utf-8") as f:
    f.write(
"""// generated by gen_property_hash.py
%language=C++
%define class-name CSSPropertyIdHash
%define lookup-function-name PropertyNameToId
%define word-array-name css_property_word_list

%{
#include "html/css/property/property_id.h"
#include <string.h>

namespace html {
%}

struct CSSPropertyIdHashEntry { 
  const char* name; 
  int id; 
};
%%
""")
    for id, name in properties:
      name = name.strip('"')
      f.write(f"{name}, (int)html::CSSPropertyId::{id}\n")


def run(commands: list[str], cwd_dir):
    print(" ".join(commands))
    ret = subprocess.run(commands, cwd=cwd_dir,
                         stdout=subprocess.PIPE, 
                         stderr=subprocess.PIPE)
    output = ret.stdout.decode("utf-8")
    error = ret.stderr.decode("utf-8")
    if error:
      print(error)

    return ret.returncode, output

  
def gperf(output_dir):
  # -D 不使用register关键字
  # gperf -t property_id.template > property_id_hash.cpp
  # gen_dir = os.path.join(SCRIPT_DIR, "gen")

  gperf_path = "gperf"
  if sys.platform=="win32":
    gperf_path="gperf.exe"

  if not shutil.which(gperf_path):
    print("Error: gperf is not exist: " + gperf_path)
    exit(-1)

  code, output = run([gperf_path, "-t", "property_id.template"], output_dir)
  hash_cpp_path = os.path.join(output_dir, "property_id_hash.cpp")
  if code != 0:
    print("run gperf failed")
    exit(1)

  # 1. 去掉register关键字，c++17已经不再支持
  output = output.replace("register ", "")

  # 2. 去掉 #line行，
  newline = "\n"
  if sys.platform == "win32":
    newline = "\r\n"
  lines = output.split(newline)
  output = "\n".join([line for line in lines if not line.startswith("#line ")])

  # 2. 补全namespace后面那个括号
  suffix ="""
// 外部调用的函数。
CSSPropertyId CSSPropertyNameToIdByHash(const char* name, unsigned int len) {
  CSSPropertyIdHashEntry* entry = CSSPropertyIdHash::PropertyNameToId(name, len);
  return entry ? (CSSPropertyId)entry->id : html::CSSPropertyId::Invalid;
}

} // namespace html
"""
  output += suffix

  with open(hash_cpp_path, "w", encoding="utf-8") as f:
    f.write(output)


def main(output_dir):
  properties = read_property_id_name_list()
  gen_gperf_template(output_dir, properties)
  gperf(output_dir)


if __name__ == "__main__":
  output_dir = sys.argv[1] or os.path.join(SCRIPT_DIR, "gen")
  main(output_dir)
