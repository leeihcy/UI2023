import os
import sys
import shutil
import subprocess

"""
生成 <opt.class_name> 完美hash, 用于实现O(1)将name转成id 
调用示例：
python hash_gen.py <input_h_path> <class_name> <name> <output_dir>

输出：
<TARGET_NAME_LOWER>.template
<TARGET_NAME_LOWER>_hash.cpp
"""

SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
HTML_ROOT_DIR = SCRIPT_DIR

class Options:
  def __init__(self):
    self.input_filepath = ''
    self.class_name = ''
    self.name = ''
    self.out_dir = ''

  def include_path(self):
    return "html/" + os.path.relpath(self.input_filepath, HTML_ROOT_DIR)
  
  def output_template_filename(self):
    return self.name + ".template"
  
  def output_cpp_filename(self):
    return self.name + "_hash.cpp"
opt = Options()


def read_value_id_name_list():
  """
  从 头文件 中读取所有的属性列表
  """
  property_id_h_path = opt.input_filepath

  class StateContext:
    def __init__(self):
      self.state = 0
      self.result = []

  def state_find_enum(line, c):
    if line.startswith(f"enum class {opt.class_name}"): 
      c.state+=1
  def state_get_id_name(line, c):
    line = line.strip(" \t\n\r")
    if line.startswith("}"):
      c.state+=1
      return

    if line[:2] == "//":
      return
    
    # 格式：
    # ValueId = 99, // "ValueName"

    id = line.split(",")[0].split("=")[0].strip()
    if "//" not in line:
      return
    value = line.split("//")[-1].strip()

    if id and value:
      c.result.append((id, value))

  def state_pass(line, c):
    pass
  
  # 状态机
  state_function = [
    state_find_enum,
    state_get_id_name,
    state_pass
  ]

  c = StateContext()
  with open(property_id_h_path, "r", encoding="utf-8") as f:
    for line in f:
      state_function[c.state](line, c)

  return c.result


def write_custom_source(f, properties):
  f.write("%{")
  f.write(f"""
#include "{opt.include_path()}"
#include <string.h>

namespace html {{
""")
  
  # id to name 映射表
  write_id_to_name_map(f, properties)

  f.write("%}")
  # } // namespace 在最后补上

def write_id_to_name_map(f, properties):
  offsets = []
  counter = 0

  f.write("static const char kStringPool[] = {\n")
  for id, name in properties:
    offsets.append(counter)
    name = name.strip('"')
    f.write(f'  "{name}\\0"\n')
    counter += len(name)+1
  f.write("};\n")

  f.write("static const uint16_t kStringOffsets[] = {\n")
  for o in offsets:
    f.write(f'  {o},\n')
  f.write("};\n")

def gen_gperf_template(output_dir, properties):
  """
  生成gperf输入模板
  """
  # output_dir = os.path.join(SCRIPT_DIR, "gen")
  if not os.path.exists(output_dir):
    os.mkdir(output_dir)

  template_path = os.path.join(output_dir, opt.output_template_filename())
  with open(template_path, "w", encoding="utf-8") as f:

    # gperf内容
    f.write(
f"""// generated by hash_gen.py"
%language=C++
%define class-name {opt.class_name}Hash
%define lookup-function-name {opt.class_name}NameToId
%define word-array-name {opt.name}_list

""")  
    
    write_custom_source(f, properties)

    f.write(
f"""
struct {opt.class_name}HashEntry {{
  const char* name; 
  int id; 
}};
%%
""")
    for id, name in properties:
      name = name.strip('"')
      f.write(f"{name}, (int)html::{opt.class_name}::{id}\n")


def run(commands: list[str], cwd_dir):
    print(" ".join(commands))
    ret = subprocess.run(commands, cwd=cwd_dir,
                         stdout=subprocess.PIPE, 
                         stderr=subprocess.PIPE)
    output = ret.stdout.decode("utf-8")
    error = ret.stderr.decode("utf-8")
    if error:
      print(error)

    return ret.returncode, output

  
def gperf(output_dir):
  # -D 不使用register关键字
  # gperf -t property_value.template > property_value_hash.cpp
  # gen_dir = os.path.join(SCRIPT_DIR, "gen")

  gperf_path = "gperf"
  if sys.platform=="win32":
    gperf_path="gperf.exe"

  if not shutil.which(gperf_path):
    print("Error: gperf is not exist: " + gperf_path)
    exit(-1)

  code, output = run([gperf_path, "-t", opt.output_template_filename()], output_dir)
  hash_cpp_path = os.path.join(output_dir, opt.output_cpp_filename())
  if code != 0:
    print("run gperf failed")
    exit(1)

  # 1. 去掉register关键字，c++17已经不再支持
  output = output.replace("register ", "")

  # 2. 去掉 #line行，
  newline = "\n"
  if sys.platform == "win32":
    newline = "\r\n"
  lines = output.split(newline)
  output = "\n".join([line for line in lines if not line.startswith("#line ")])

  # 2. 补全namespace后面那个括号
  suffix = f"""
// 外部调用的函数。
{opt.class_name} {opt.class_name}NameToIdByHash(const char* name, unsigned int len) {{
  {opt.class_name}HashEntry* entry = {opt.class_name}Hash::{opt.class_name}NameToId(name, len);
  return entry ? ({opt.class_name})entry->id : html::{opt.class_name}::Invalid;
}}

const char* Get{opt.class_name}Name({opt.class_name} id) {{
  uint16_t index = (uint16_t)id;
  if (index > sizeof(kStringOffsets)) {{ return nullptr; }}

  uint16_t offset_index = kStringOffsets[index];
  if (offset_index > sizeof(kStringPool)) {{ return nullptr; }}

  return &kStringPool[offset_index];
}}
}} // namespace html
"""
  output += suffix

  with open(hash_cpp_path, "w", encoding="utf-8") as f:
    f.write(output)


def main():
  properties = read_value_id_name_list()
  gen_gperf_template(opt.out_dir, properties)
  gperf(opt.out_dir)


if __name__ == "__main__":
  opt.input_filepath = sys.argv[1]
  opt.class_name = sys.argv[2]
  opt.name = sys.argv[3]
  opt.out_dir = sys.argv[4]
  main()
