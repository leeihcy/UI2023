import os
import sys
import shutil
import subprocess
import json5

"""
生成 <opt.class_name> 完美hash, 用于实现O(1)将name转成id 
调用示例：
python hash_gen.py <input_h_path> <class_name> <name> <output_dir>

输出：
<TARGET_NAME_LOWER>.template
<TARGET_NAME_LOWER>_hash.cpp
"""

SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
HTML_ROOT_DIR = SCRIPT_DIR

class Options:
  def __init__(self):
    self._input_filepath = ''
    self._out_dir = ''
  
  def parse(self):
    self._input_filepath = sys.argv[1]
    self._out_dir = sys.argv[2]

  def input_filepath(self):
    return self._input_filepath
  
  def out_dir(self):
    return self._out_dir

  def file_base_name(self):
    base, ext = os.path.splitext(os.path.basename(self._input_filepath))
    return base
  
  def header_file_name(self):
    return self.file_base_name() + "_enum.h"
  
  def header_file_path(self):
    return os.path.join(opt._out_dir, self.header_file_name())
  
  def relative_dir(self):
    return "html/" + os.path.relpath(os.path.dirname(self._input_filepath), HTML_ROOT_DIR)
  
  def include_text(self):
    return self.relative_dir() + "/" + self.header_file_name()
  
  def include_path(self):
    return os.path.join(self.relative_dir(), self.header_file_name())
  
  def output_template_filename(self):
    return self.file_base_name() + "_hash.template"
  
  def output_cpp_filename(self):
    return self.file_base_name() + "_hash.cpp"
opt = Options()

class ClassInfo:
  def __init__(self):
    self.class_name = ""
    self.list = []  # (Id, Name)
class_info = ClassInfo()

# 解析描述文件
def parse_class_info():
  with open(opt.input_filepath(), "r", encoding="utf-8") as f:
    json_data = json5.load(f)
  class_info.class_name = json_data["class_name"]

  for i in json_data["data"]:
    class_info.list.append((i.get("id"), i.get("text")))


# 生成头文件
def gen_header():
  header_file_path = opt.header_file_path()

  define_text = opt.include_text().upper().replace("/", "_").replace(".", "_")
  with open(header_file_path, "w", encoding="utf-8") as f:
    f.write(f"""
// generated by {os.path.basename(__file__)}

#ifndef _{define_text}_
#define _{define_text}_

namespace html {{

enum class {class_info.class_name} : unsigned short {{
""")

    for index, i in enumerate(class_info.list):
      f.write(f"  {i[0]} = {index},\n");

    f.write("""
};

}

#endif
""")

def write_custom_source(f):
  f.write("%{")
  f.write(f"""
#include "{opt.include_path()}"
#include <string.h>

namespace html {{
""")
  
  # id to name 映射表
  write_id_to_name_map(f)

  f.write("%}")
  # } // namespace 在最后补上

def write_id_to_name_map(f):
  offsets = []
  counter = 0

  f.write("static const char kStringPool[] = {\n")
  for index, (id, name) in enumerate(class_info.list):
    offsets.append(counter)
    if not name:
      name = "\\0"
      counter += 1
    else:
      name += "\\0"
      counter += len(name)+1

    f.write(f'  "{name}"\n')
   
  f.write("};\n")

  f.write("static const unsigned short kStringOffsets[] = {\n")
  for o in offsets:
    f.write(f'  {o},\n')
  f.write("};\n")

def gen_gperf_template():
  """
  生成gperf输入模板
  """
  output_dir = opt.out_dir()
  if not os.path.exists(output_dir):
    os.mkdir(output_dir)

  template_path = os.path.join(output_dir, opt.output_template_filename())
  with open(template_path, "w", encoding="utf-8") as f:

    # gperf内容
    f.write(
f"""// generated by {os.path.basename(__file__)}"
%language=C++
%define class-name {class_info.class_name}Hash
%define lookup-function-name {class_info.class_name}NameToId
%define word-array-name {opt.file_base_name()}_list

""")  
    
    write_custom_source(f)

    f.write(
f"""
struct {class_info.class_name}HashEntry {{
  const char* name; 
  int id; 
}};
%%
""")
    for index, (id, name) in enumerate(class_info.list):
      if not name:
        continue
      name = name.strip('"')
      f.write(f'{name}, {index}\n')


def run(commands: list[str], cwd_dir):
    print(" ".join(commands))
    ret = subprocess.run(commands, cwd=cwd_dir,
                         stdout=subprocess.PIPE, 
                         stderr=subprocess.PIPE)
    output = ret.stdout.decode("utf-8")
    error = ret.stderr.decode("utf-8")
    if error:
      print(error)

    return ret.returncode, output

  
def gperf():
  # -D 不使用register关键字
  # gperf -t property_value.template > property_value_hash.cpp
  # gen_dir = os.path.join(SCRIPT_DIR, "gen")

  output_dir = opt.out_dir()
  gperf_path = "gperf"
  if sys.platform == "win32":
    gperf_path="gperf.exe"

  if not shutil.which(gperf_path):
    print("Error: gperf is not exist: " + gperf_path)
    exit(-1)

  code, output = run([gperf_path, "-t", opt.output_template_filename()], output_dir)
  hash_cpp_path = os.path.join(output_dir, opt.output_cpp_filename())
  if code != 0:
    print("run gperf failed")
    exit(1)

  # 1. 去掉register关键字，c++17已经不再支持
  output = output.replace("register ", "")

  # 2. 去掉 #line行，
  newline = "\n"
  if sys.platform == "win32":
    newline = "\r\n"
  lines = output.split(newline)
  output = "\n".join([line for line in lines if not line.startswith("#line ")])

  # 2. 补全namespace后面那个括号
  class_name = class_info.class_name
  suffix = f"""
// 外部调用的函数。
{class_name} {class_name}NameToIdByHash(const char* name, unsigned int len) {{
  {class_name}HashEntry* entry = {class_name}Hash::{class_name}NameToId(name, len);
  return entry ? ({class_name})entry->id : html::{class_name}::Invalid;
}}

const char* Get{class_name}Name({class_name} id) {{
  unsigned short index = (unsigned short)id;
  if (index > sizeof(kStringOffsets)) {{ return nullptr; }}

  unsigned short offset_index = kStringOffsets[index];
  if (offset_index > sizeof(kStringPool)) {{ return nullptr; }}

  return &kStringPool[offset_index];
}}
}} // namespace html
"""
  output += suffix

  with open(hash_cpp_path, "w", encoding="utf-8") as f:
    f.write(output)


def main():
  parse_class_info()
  gen_header()
  gen_gperf_template()
  gperf()


if __name__ == "__main__":
  opt.parse()
  main()
